ty="{exists List::(*) => (*),{cons_:forall X::*.(X -> ((List[X]) -> (List[X]))), head_:forall X::*.((List[X]) -> X), isnil_:forall X::*.((List[X]) -> Bool), nil_:forall X::*.(List[X])}}"
evaluated="{*\\X::*.forall R::*.((X -> (R -> R)) -> (R -> R)),{cons_=\\X::*.\\hd:X.(\\tl:forall R::*.((X -> (R -> R)) -> (R -> R)).(\\R::*.(\\c:(X -> (R -> R)).(\\n:R.(((c) (hd)) (((((tl)[R])) (c)) (n))))))), head_=\\X::*.\\l:forall R::*.((X -> (R -> R)) -> (R -> R)).(((((l)[X])) (\\hd:X.(\\tl:X.(hd)))) ((((\\X::*.(\\_:Unit.(fix(\\x:X.(x)))))[X])) (unit))), isnil_=\\X::*.\\l:forall R::*.((X -> (R -> R)) -> (R -> R)).(((((l)[Bool])) (\\hd:X.(\\tl:Bool.(false)))) (true)), nil_=\\X::*.\\R::*.(\\c:(X -> (R -> R)).(\\n:R.(n)))}} as {exists List::(*) => (*),{cons_:forall X::*.(X -> ((List[X]) -> (List[X]))), head_:forall X::*.((List[X]) -> X), isnil_:forall X::*.((List[X]) -> Bool), nil_:forall X::*.(List[X])}}"
