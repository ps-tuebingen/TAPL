let (isnil_ = 
    \l:(mu X.<nil_:Unit, cons_:(Nat x X)>).
    case (unfold [mu X.<nil_:Unit,cons_:(Nat x X)>] l) of {
      <nil_=u> => true
      | <cons_=p> => false
    }
) in 
let (head_ = \l:(mu X.<nil_:Unit, cons_:(Nat x X)>). 
    case (unfold [mu X.<nil_:Unit,cons_:(Nat x X)>] l) of {
      <nil_=u> => 0
      | <cons_=p> => p.fst
    }
) in
let (tail_ = \l:(mu X.<nil_:Unit, cons_:(Nat x X)>).
      case (unfold [mu X.<nil_:Unit,cons_:(Nat x X)>] l) of {
      <nil_=u> => l
      | <cons_=p> => p.snd
      }
) in
let (plus = fix(
  \f:Nat->(Nat->Nat).\n:Nat.\m:Nat.
  if (iszero(n)) {
    m
  }else {
    (f(pred(n)))(m)
  }
)) in 
fix (
  \s:(mu X.<nil_:Unit, cons_:(Nat x X)>)->Nat.
  \l:(mu X.<nil_:Unit, cons_:(Nat x X)>). 
  if (isnil_(l)) {
    0 
  } else {
    (plus (head_ l)) (s(tail_(l)))
  }
)
