ty="(mu X.<cons_:(Nat x X), nil_:Unit> -> Nat)"
evaluated="\\l:mu X.<cons_:(Nat x X), nil_:Unit>.(if ((\\l:mu X.<cons_:(Nat x X), nil_:Unit>.(case unfold[mu X.<cons_:(Nat x X), nil_:Unit>](l) of { <cons_ = p> => false| <nil_ = u> => true })) (l)) { 0 } else { ((\\n:Nat.(\\m:Nat.(if (iszero(n)) { m } else { ((fix(\\f:(Nat -> (Nat -> Nat)).(\\n:Nat.(\\m:Nat.(if (iszero(n)) { m } else { ((f) (pred(n))) (m) }))))) (pred(n))) (m) }))) ((\\l:mu X.<cons_:(Nat x X), nil_:Unit>.(case unfold[mu X.<cons_:(Nat x X), nil_:Unit>](l) of { <cons_ = p> => p.fst| <nil_ = u> => 0 })) (l))) ((fix(\\s:(mu X.<cons_:(Nat x X), nil_:Unit> -> Nat).(\\l:mu X.<cons_:(Nat x X), nil_:Unit>.(if ((\\l:mu X.<cons_:(Nat x X), nil_:Unit>.(case unfold[mu X.<cons_:(Nat x X), nil_:Unit>](l) of { <cons_ = p> => false| <nil_ = u> => true })) (l)) { 0 } else { ((\\n:Nat.(\\m:Nat.(if (iszero(n)) { m } else { ((fix(\\f:(Nat -> (Nat -> Nat)).(\\n:Nat.(\\m:Nat.(if (iszero(n)) { m } else { ((f) (pred(n))) (m) }))))) (pred(n))) (m) }))) ((\\l:mu X.<cons_:(Nat x X), nil_:Unit>.(case unfold[mu X.<cons_:(Nat x X), nil_:Unit>](l) of { <cons_ = p> => p.fst| <nil_ = u> => 0 })) (l))) ((s) ((\\l:mu X.<cons_:(Nat x X), nil_:Unit>.(case unfold[mu X.<cons_:(Nat x X), nil_:Unit>](l) of { <cons_ = p> => (p).snd| <nil_ = u> => l })) (l))) })))) ((\\l:mu X.<cons_:(Nat x X), nil_:Unit>.(case unfold[mu X.<cons_:(Nat x X), nil_:Unit>](l) of { <cons_ = p> => (p).snd| <nil_ = u> => l })) (l))) })"
