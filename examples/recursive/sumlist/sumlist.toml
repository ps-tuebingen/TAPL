ty=""
evaluated="\\l:(mu X.<cons:{ Nat, X }, nil:Unit>).(if (((\\l:(mu X.<cons:{ Nat, X }, nil:Unit>).(case l of { <nil=u> => true| <cons=p> => false })) (l))) { zero } else { ((\\n:(Nat).(\\m:(Nat).(if (iszero(n)) { m } else { ((((fix (\\f:((Nat) -> ((Nat) -> (Nat))).(\\n:(Nat).(\\m:(Nat).(if (iszero(n)) { m } else { ((((f) (pred(n)))) (m)) }))))) (pred(n)))) (m)) }))) (((((\\l:(mu X.<cons:{ Nat, X }, nil:Unit>).(case l of { <nil=u> => zero| <cons=p> => p.0 })) (l))) (((fix (\\s:((mu X.<cons:{ Nat, X }, nil:Unit>) -> (Nat)).(\\l:(mu X.<cons:{ Nat, X }, nil:Unit>).(if (((\\l:(mu X.<cons:{ Nat, X }, nil:Unit>).(case l of { <nil=u> => true| <cons=p> => false })) (l))) { zero } else { ((\\n:(Nat).(\\m:(Nat).(if (iszero(n)) { m } else { ((((fix (\\f:((Nat) -> ((Nat) -> (Nat))).(\\n:(Nat).(\\m:(Nat).(if (iszero(n)) { m } else { ((((f) (pred(n)))) (m)) }))))) (pred(n)))) (m)) }))) (((((\\l:(mu X.<cons:{ Nat, X }, nil:Unit>).(case l of { <nil=u> => zero| <cons=p> => p.0 })) (l))) (((s) (((\\l:(mu X.<cons:{ Nat, X }, nil:Unit>).(case l of { <nil=u> => l| <cons=p> => p.1 })) (l)))))))) })))) (((\\l:(mu X.<cons:{ Nat, X }, nil:Unit>).(case l of { <nil=u> => l| <cons=p> => p.1 })) (l)))))))) })"
