ty="(mu X.<cons:(Nat x X), nil:Unit> -> Nat)"
evaluated="\\l:mu X.<cons:(Nat x X), nil:Unit>.(if ((\\l:mu X.<cons:(Nat x X), nil:Unit>.(case unfold[mu X.<cons:(Nat x X), nil:Unit>](l) of { <cons = p> => false| <nil = u> => true })) (l)) { 0 } else { ((\\n:Nat.(\\m:Nat.(if (iszero(n)) { m } else { ((fix(\\f:(Nat -> (Nat -> Nat)).(\\n:Nat.(\\m:Nat.(if (iszero(n)) { m } else { ((f) (pred(n))) (m) }))))) (pred(n))) (m) }))) ((\\l:mu X.<cons:(Nat x X), nil:Unit>.(case unfold[mu X.<cons:(Nat x X), nil:Unit>](l) of { <cons = p> => p.0| <nil = u> => 0 })) (l))) ((fix(\\s:(mu X.<cons:(Nat x X), nil:Unit> -> Nat).(\\l:mu X.<cons:(Nat x X), nil:Unit>.(if ((\\l:mu X.<cons:(Nat x X), nil:Unit>.(case unfold[mu X.<cons:(Nat x X), nil:Unit>](l) of { <cons = p> => false| <nil = u> => true })) (l)) { 0 } else { ((\\n:Nat.(\\m:Nat.(if (iszero(n)) { m } else { ((fix(\\f:(Nat -> (Nat -> Nat)).(\\n:Nat.(\\m:Nat.(if (iszero(n)) { m } else { ((f) (pred(n))) (m) }))))) (pred(n))) (m) }))) ((\\l:mu X.<cons:(Nat x X), nil:Unit>.(case unfold[mu X.<cons:(Nat x X), nil:Unit>](l) of { <cons = p> => p.0| <nil = u> => 0 })) (l))) ((s) ((\\l:mu X.<cons:(Nat x X), nil:Unit>.(case unfold[mu X.<cons:(Nat x X), nil:Unit>](l) of { <cons = p> => (p).1| <nil = u> => l })) (l))) })))) ((\\l:mu X.<cons:(Nat x X), nil:Unit>.(case unfold[mu X.<cons:(Nat x X), nil:Unit>](l) of { <cons = p> => (p).1| <nil = u> => l })) (l))) })"
